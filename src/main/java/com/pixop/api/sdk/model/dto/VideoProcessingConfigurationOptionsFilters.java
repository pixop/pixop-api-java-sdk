/*
 * Pixop API Documentation
 *  The Pixop API provides a comprehensive RESTful interface for interacting with the Pixop Platform. It allows users to manage API keys, projects, videos, and more.  The Pixop Platform offers video processing features such as upscaling, format conversion, and compression. It uses AI-driven algorithms to optimize video quality, reduce file sizes, and improve playback performance.  **Quick Start Guide** - Explore the [Pixop API Documentation](https://docs.pixop.com/reference/) to familiarize yourself with the API's capabilities.  **Required Headers** Include the following headers in all API requests: - `Accept`: `application/json` - `Content-Type`: `application/json` - `X-API-Key`: Your API key for authentication (e.g., `X-API-Key: <your-api-key>`).     **Note:** API key management endpoints that use Basic Authentication do not require the `X-API-Key` header.  **Rate Limits** All endpoints, except those related to API key management, enforce rate limits. Response headers provide the following rate limit details: - `X-RateLimit-Limit`: The maximum number of requests allowed per minute. - `X-RateLimit-Remaining`: The number of requests remaining in the current rate limit window. - `X-RateLimit-Reset`: The number of seconds until the current rate limit window resets. 
 *
 * The version of the OpenAPI document: 1.0.0-rc.1
 * Contact: api@pixop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pixop.api.sdk.model.dto;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.pixop.api.sdk.JSON;

/**
 * Specifies the filters to apply to the video. To disable a specific filter, set its value to &#x60;null&#x60; or remove the corresponding field. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-05-22T07:45:21.409035112Z[UTC]", comments = "Generator version: 7.12.0")
public class VideoProcessingConfigurationOptionsFilters {
  /**
   * Specifies the deinterlacer to use for video processing.  **Additional settings must be set on &#x60;filterSettings.interlacedFieldOrderMode&#x60;** E.g.:    - &#x60;DEINT&#x60;: Pixop Deinterlacer. Pixop&#39;s deep neural network based video deinterlacer which reduces aliasing artifacts such as interline twitter. Doubles the output frame rate.   - &#x60;YADIF&#x60;: “Yet Another DeInterlacing Filter”. Classic deinterlacer which checks the pixels of previous, current and next frames to re-create the missed field via edge-directed interpolation and applies a spatial check to prevent most artifacts.   - &#x60;BWDIF&#x60;: Bob Weaver. Classic deinterlacer based on a motion adaptive approach that fuses the YADIF and Weston 3-Field methods. Doubles the output frame rate.   - &#x60;WESTON3F&#x60;: Weston Three Field. Classic deinterlacer that considers the same position in the previous and next fields and two of its neighbors in both directions in the current field. Doubles the output frame rate. 
   */
  @JsonAdapter(DeinterlacerEnum.Adapter.class)
  public enum DeinterlacerEnum {
    DEINT("DEINT"),
    
    YADIF("YADIF"),
    
    BWDIF("BWDIF"),
    
    WESTON3_F("WESTON3F");

    private String value;

    DeinterlacerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DeinterlacerEnum fromValue(String value) {
      for (DeinterlacerEnum b : DeinterlacerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DeinterlacerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DeinterlacerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DeinterlacerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DeinterlacerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DeinterlacerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEINTERLACER = "deinterlacer";
  @SerializedName(SERIALIZED_NAME_DEINTERLACER)
  @javax.annotation.Nullable
  private DeinterlacerEnum deinterlacer;

  /**
   * Specifies the reshaper to use for video processing. For instance:   - &#x60;CROP&#x60;: Frame Cropper. **Additional settings must be set on &#x60;filterSettings.normalizedCropCoordinates&#x60;** 
   */
  @JsonAdapter(ReshaperEnum.Adapter.class)
  public enum ReshaperEnum {
    CROP("CROP");

    private String value;

    ReshaperEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ReshaperEnum fromValue(String value) {
      for (ReshaperEnum b : ReshaperEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ReshaperEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ReshaperEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ReshaperEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ReshaperEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ReshaperEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_RESHAPER = "reshaper";
  @SerializedName(SERIALIZED_NAME_RESHAPER)
  @javax.annotation.Nullable
  private ReshaperEnum reshaper;

  /**
   * Specifies the denoiser to use for video processing. For instance: - &#x60;DENOISE&#x60;: Pixop&#39;s deep neural network-based video denoiser trained on a spatio-temporal gaussian noise model. - &#x60;HQDN3D&#x60;: High Quality DeNoise 3D. Classic denoiser based on a three-way low-pass filter, which can completely remove high-frequency noise while minimizing blending artifacts. 
   */
  @JsonAdapter(DenoiserEnum.Adapter.class)
  public enum DenoiserEnum {
    DENOISE("DENOISE"),
    
    HQDN3_D("HQDN3D");

    private String value;

    DenoiserEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DenoiserEnum fromValue(String value) {
      for (DenoiserEnum b : DenoiserEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DenoiserEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DenoiserEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DenoiserEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DenoiserEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DenoiserEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DENOISER = "denoiser";
  @SerializedName(SERIALIZED_NAME_DENOISER)
  @javax.annotation.Nullable
  private DenoiserEnum denoiser;

  /**
   * Specifies the stabilizer to use for video processing. For instance: - &#x60;DEJIT&#x60;: Pixop Dejitterer. Pixop&#39;s deep neural network based video dejitterer designed for stabilizing video that has been transferred to digital by re-aligning scanlines. 
   */
  @JsonAdapter(StabilizerEnum.Adapter.class)
  public enum StabilizerEnum {
    DEJIT("DEJIT");

    private String value;

    StabilizerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StabilizerEnum fromValue(String value) {
      for (StabilizerEnum b : StabilizerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StabilizerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StabilizerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StabilizerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StabilizerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StabilizerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STABILIZER = "stabilizer";
  @SerializedName(SERIALIZED_NAME_STABILIZER)
  @javax.annotation.Nullable
  private StabilizerEnum stabilizer;

  /**
   * Specifies the augmenter to use for video processing. For instance: - &#x60;FACEFORWARD&#x60;: Pixop&#39;s face enhancement augmenter for recordings of human presenters. Makes lighting appear uniform across the entire face of the subject(s), blurs the background and performs color adjustments. To obtain the desired effect, the entire face must be clearly visible, partially front lit, fill at least 5% of the image frame and remain relatively still. **Additional settings must be set on &#x60;filterSettings.faceForward&#x60;** 
   */
  @JsonAdapter(AugmenterEnum.Adapter.class)
  public enum AugmenterEnum {
    FACEFORWARD("FACEFORWARD");

    private String value;

    AugmenterEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static AugmenterEnum fromValue(String value) {
      for (AugmenterEnum b : AugmenterEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<AugmenterEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AugmenterEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AugmenterEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return AugmenterEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      AugmenterEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_AUGMENTER = "augmenter";
  @SerializedName(SERIALIZED_NAME_AUGMENTER)
  @javax.annotation.Nullable
  private AugmenterEnum augmenter;

  /**
   * Specifies the scaler to use for video processing. **Additional settings must be set on &#x60;filterSettings.resolution&#x60;** when set. For instance:   - &#x60;DVRES2&#x60;: Pixop Deep Restoration 2. Pixop&#39;s improved deep neural network based video restoration algorithm. **Additional settings can be set on &#x60;filterSettings.dvres2Variant&#x60;**   - &#x60;DVRES&#x60;:  Pixop Deep Restoration. Pixop&#39;s original deep neural network based video restoration algorithm. Optionally scales, then deblurs, eliminates compression artifacts and injects details into degraded video (max HD resolution). For fair to good quality digital SD material.   - &#x60;PABSR1&#x60;: Pixop Super Resolution. Pixop&#39;s machine-learned based scaler. Allows upscaling up to 4x of the original displayed frame size. Neither restoration nor AI detail injection is performed. Can optionally be applied without upscaling as final sweetening. **Additional settings must be set on &#x60;filterSettings.clarityBoost&#x60;**   - &#x60;SCALE&#x60;:  Bicubic Interpolation. Classic scaler using the bicubic interpolation resampling method. Allows both upscaling and downscaling. 
   */
  @JsonAdapter(ScalerEnum.Adapter.class)
  public enum ScalerEnum {
    DVRES2("DVRES2"),
    
    DVRES("DVRES"),
    
    PABSR1("PABSR1"),
    
    SCALE("SCALE");

    private String value;

    ScalerEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ScalerEnum fromValue(String value) {
      for (ScalerEnum b : ScalerEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<ScalerEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ScalerEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ScalerEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return ScalerEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      ScalerEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCALER = "scaler";
  @SerializedName(SERIALIZED_NAME_SCALER)
  @javax.annotation.Nullable
  private ScalerEnum scaler;

  /**
   * Specifies the frame rate converter to use for video processing. **Additional settings must be set on &#x60;filterSettings.frameRate&#x60;** when set. For instance:   - &#x60;VFI&#x60;: Pixop Frame Rate Conversion. Pixop&#39;s deep learning method for converting the frame rate accurately by estimating and interpolating the motion between two consecutive frames. Fast motion, line of sight being blocked by an intervening object and scene changes are handled.   - &#x60;FPS&#x60;: Constant FPS. Classic frame rate converter which converts the video to the specified constant frame rate by simply duplicating or dropping source frames as necessary.   - &#x60;FBLEND&#x60;: Frame Blending. Classic frame rate converter that changes the frame rate by blending new video output frames from the source frames.   - &#x60;MCINTERPOLATE&#x60;: Motion Compensation. Classic frame rate converter based on an advanced motion compensation interpolation algorithm. 
   */
  @JsonAdapter(FrameRateConverterEnum.Adapter.class)
  public enum FrameRateConverterEnum {
    VFI("VFI"),
    
    FPS("FPS"),
    
    FBLEND("FBLEND"),
    
    MCINTERPOLATE("MCINTERPOLATE");

    private String value;

    FrameRateConverterEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FrameRateConverterEnum fromValue(String value) {
      for (FrameRateConverterEnum b : FrameRateConverterEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FrameRateConverterEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FrameRateConverterEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FrameRateConverterEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FrameRateConverterEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FrameRateConverterEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FRAME_RATE_CONVERTER = "frameRateConverter";
  @SerializedName(SERIALIZED_NAME_FRAME_RATE_CONVERTER)
  @javax.annotation.Nullable
  private FrameRateConverterEnum frameRateConverter;

  /**
   * Specifies the debander to use for video processing. For instance: - &#x60;GRADFUN&#x60;: Gradient Debander. Fixes the banding artifacts that are sometimes introduced into nearly flat regions. Interpolate the gradients that should go where the bands are, and dither them. 
   */
  @JsonAdapter(DebanderEnum.Adapter.class)
  public enum DebanderEnum {
    GRADFUN("GRADFUN");

    private String value;

    DebanderEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DebanderEnum fromValue(String value) {
      for (DebanderEnum b : DebanderEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<DebanderEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DebanderEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DebanderEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DebanderEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      DebanderEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_DEBANDER = "debander";
  @SerializedName(SERIALIZED_NAME_DEBANDER)
  @javax.annotation.Nullable
  private DebanderEnum debander;

  /**
   * Specifies the post-processor to use for video processing. For instance: - &#x60;FILMGRAIN&#x60;: Pixop Film Grain.  Adds a layer of digital film grain to the processed output using a physically-based grain model. By applying this filter, an element of materiality is injected, which makes denoised material look more attractive to some human observers, for example. **Additional settings must be set on &#x60;filterSettings.filmGrain&#x60;** 
   */
  @JsonAdapter(PostProcessorEnum.Adapter.class)
  public enum PostProcessorEnum {
    FILMGRAIN("FILMGRAIN");

    private String value;

    PostProcessorEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PostProcessorEnum fromValue(String value) {
      for (PostProcessorEnum b : PostProcessorEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PostProcessorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PostProcessorEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PostProcessorEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PostProcessorEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      PostProcessorEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_POST_PROCESSOR = "postProcessor";
  @SerializedName(SERIALIZED_NAME_POST_PROCESSOR)
  @javax.annotation.Nullable
  private PostProcessorEnum postProcessor;

  public VideoProcessingConfigurationOptionsFilters() {
  }

  public VideoProcessingConfigurationOptionsFilters deinterlacer(@javax.annotation.Nullable DeinterlacerEnum deinterlacer) {
    this.deinterlacer = deinterlacer;
    return this;
  }

  /**
   * Specifies the deinterlacer to use for video processing.  **Additional settings must be set on &#x60;filterSettings.interlacedFieldOrderMode&#x60;** E.g.:    - &#x60;DEINT&#x60;: Pixop Deinterlacer. Pixop&#39;s deep neural network based video deinterlacer which reduces aliasing artifacts such as interline twitter. Doubles the output frame rate.   - &#x60;YADIF&#x60;: “Yet Another DeInterlacing Filter”. Classic deinterlacer which checks the pixels of previous, current and next frames to re-create the missed field via edge-directed interpolation and applies a spatial check to prevent most artifacts.   - &#x60;BWDIF&#x60;: Bob Weaver. Classic deinterlacer based on a motion adaptive approach that fuses the YADIF and Weston 3-Field methods. Doubles the output frame rate.   - &#x60;WESTON3F&#x60;: Weston Three Field. Classic deinterlacer that considers the same position in the previous and next fields and two of its neighbors in both directions in the current field. Doubles the output frame rate. 
   * @return deinterlacer
   */
  @javax.annotation.Nullable
  public DeinterlacerEnum getDeinterlacer() {
    return deinterlacer;
  }

  public void setDeinterlacer(@javax.annotation.Nullable DeinterlacerEnum deinterlacer) {
    this.deinterlacer = deinterlacer;
  }


  public VideoProcessingConfigurationOptionsFilters reshaper(@javax.annotation.Nullable ReshaperEnum reshaper) {
    this.reshaper = reshaper;
    return this;
  }

  /**
   * Specifies the reshaper to use for video processing. For instance:   - &#x60;CROP&#x60;: Frame Cropper. **Additional settings must be set on &#x60;filterSettings.normalizedCropCoordinates&#x60;** 
   * @return reshaper
   */
  @javax.annotation.Nullable
  public ReshaperEnum getReshaper() {
    return reshaper;
  }

  public void setReshaper(@javax.annotation.Nullable ReshaperEnum reshaper) {
    this.reshaper = reshaper;
  }


  public VideoProcessingConfigurationOptionsFilters denoiser(@javax.annotation.Nullable DenoiserEnum denoiser) {
    this.denoiser = denoiser;
    return this;
  }

  /**
   * Specifies the denoiser to use for video processing. For instance: - &#x60;DENOISE&#x60;: Pixop&#39;s deep neural network-based video denoiser trained on a spatio-temporal gaussian noise model. - &#x60;HQDN3D&#x60;: High Quality DeNoise 3D. Classic denoiser based on a three-way low-pass filter, which can completely remove high-frequency noise while minimizing blending artifacts. 
   * @return denoiser
   */
  @javax.annotation.Nullable
  public DenoiserEnum getDenoiser() {
    return denoiser;
  }

  public void setDenoiser(@javax.annotation.Nullable DenoiserEnum denoiser) {
    this.denoiser = denoiser;
  }


  public VideoProcessingConfigurationOptionsFilters stabilizer(@javax.annotation.Nullable StabilizerEnum stabilizer) {
    this.stabilizer = stabilizer;
    return this;
  }

  /**
   * Specifies the stabilizer to use for video processing. For instance: - &#x60;DEJIT&#x60;: Pixop Dejitterer. Pixop&#39;s deep neural network based video dejitterer designed for stabilizing video that has been transferred to digital by re-aligning scanlines. 
   * @return stabilizer
   */
  @javax.annotation.Nullable
  public StabilizerEnum getStabilizer() {
    return stabilizer;
  }

  public void setStabilizer(@javax.annotation.Nullable StabilizerEnum stabilizer) {
    this.stabilizer = stabilizer;
  }


  public VideoProcessingConfigurationOptionsFilters augmenter(@javax.annotation.Nullable AugmenterEnum augmenter) {
    this.augmenter = augmenter;
    return this;
  }

  /**
   * Specifies the augmenter to use for video processing. For instance: - &#x60;FACEFORWARD&#x60;: Pixop&#39;s face enhancement augmenter for recordings of human presenters. Makes lighting appear uniform across the entire face of the subject(s), blurs the background and performs color adjustments. To obtain the desired effect, the entire face must be clearly visible, partially front lit, fill at least 5% of the image frame and remain relatively still. **Additional settings must be set on &#x60;filterSettings.faceForward&#x60;** 
   * @return augmenter
   */
  @javax.annotation.Nullable
  public AugmenterEnum getAugmenter() {
    return augmenter;
  }

  public void setAugmenter(@javax.annotation.Nullable AugmenterEnum augmenter) {
    this.augmenter = augmenter;
  }


  public VideoProcessingConfigurationOptionsFilters scaler(@javax.annotation.Nullable ScalerEnum scaler) {
    this.scaler = scaler;
    return this;
  }

  /**
   * Specifies the scaler to use for video processing. **Additional settings must be set on &#x60;filterSettings.resolution&#x60;** when set. For instance:   - &#x60;DVRES2&#x60;: Pixop Deep Restoration 2. Pixop&#39;s improved deep neural network based video restoration algorithm. **Additional settings can be set on &#x60;filterSettings.dvres2Variant&#x60;**   - &#x60;DVRES&#x60;:  Pixop Deep Restoration. Pixop&#39;s original deep neural network based video restoration algorithm. Optionally scales, then deblurs, eliminates compression artifacts and injects details into degraded video (max HD resolution). For fair to good quality digital SD material.   - &#x60;PABSR1&#x60;: Pixop Super Resolution. Pixop&#39;s machine-learned based scaler. Allows upscaling up to 4x of the original displayed frame size. Neither restoration nor AI detail injection is performed. Can optionally be applied without upscaling as final sweetening. **Additional settings must be set on &#x60;filterSettings.clarityBoost&#x60;**   - &#x60;SCALE&#x60;:  Bicubic Interpolation. Classic scaler using the bicubic interpolation resampling method. Allows both upscaling and downscaling. 
   * @return scaler
   */
  @javax.annotation.Nullable
  public ScalerEnum getScaler() {
    return scaler;
  }

  public void setScaler(@javax.annotation.Nullable ScalerEnum scaler) {
    this.scaler = scaler;
  }


  public VideoProcessingConfigurationOptionsFilters frameRateConverter(@javax.annotation.Nullable FrameRateConverterEnum frameRateConverter) {
    this.frameRateConverter = frameRateConverter;
    return this;
  }

  /**
   * Specifies the frame rate converter to use for video processing. **Additional settings must be set on &#x60;filterSettings.frameRate&#x60;** when set. For instance:   - &#x60;VFI&#x60;: Pixop Frame Rate Conversion. Pixop&#39;s deep learning method for converting the frame rate accurately by estimating and interpolating the motion between two consecutive frames. Fast motion, line of sight being blocked by an intervening object and scene changes are handled.   - &#x60;FPS&#x60;: Constant FPS. Classic frame rate converter which converts the video to the specified constant frame rate by simply duplicating or dropping source frames as necessary.   - &#x60;FBLEND&#x60;: Frame Blending. Classic frame rate converter that changes the frame rate by blending new video output frames from the source frames.   - &#x60;MCINTERPOLATE&#x60;: Motion Compensation. Classic frame rate converter based on an advanced motion compensation interpolation algorithm. 
   * @return frameRateConverter
   */
  @javax.annotation.Nullable
  public FrameRateConverterEnum getFrameRateConverter() {
    return frameRateConverter;
  }

  public void setFrameRateConverter(@javax.annotation.Nullable FrameRateConverterEnum frameRateConverter) {
    this.frameRateConverter = frameRateConverter;
  }


  public VideoProcessingConfigurationOptionsFilters debander(@javax.annotation.Nullable DebanderEnum debander) {
    this.debander = debander;
    return this;
  }

  /**
   * Specifies the debander to use for video processing. For instance: - &#x60;GRADFUN&#x60;: Gradient Debander. Fixes the banding artifacts that are sometimes introduced into nearly flat regions. Interpolate the gradients that should go where the bands are, and dither them. 
   * @return debander
   */
  @javax.annotation.Nullable
  public DebanderEnum getDebander() {
    return debander;
  }

  public void setDebander(@javax.annotation.Nullable DebanderEnum debander) {
    this.debander = debander;
  }


  public VideoProcessingConfigurationOptionsFilters postProcessor(@javax.annotation.Nullable PostProcessorEnum postProcessor) {
    this.postProcessor = postProcessor;
    return this;
  }

  /**
   * Specifies the post-processor to use for video processing. For instance: - &#x60;FILMGRAIN&#x60;: Pixop Film Grain.  Adds a layer of digital film grain to the processed output using a physically-based grain model. By applying this filter, an element of materiality is injected, which makes denoised material look more attractive to some human observers, for example. **Additional settings must be set on &#x60;filterSettings.filmGrain&#x60;** 
   * @return postProcessor
   */
  @javax.annotation.Nullable
  public PostProcessorEnum getPostProcessor() {
    return postProcessor;
  }

  public void setPostProcessor(@javax.annotation.Nullable PostProcessorEnum postProcessor) {
    this.postProcessor = postProcessor;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoProcessingConfigurationOptionsFilters videoProcessingConfigurationOptionsFilters = (VideoProcessingConfigurationOptionsFilters) o;
    return Objects.equals(this.deinterlacer, videoProcessingConfigurationOptionsFilters.deinterlacer) &&
        Objects.equals(this.reshaper, videoProcessingConfigurationOptionsFilters.reshaper) &&
        Objects.equals(this.denoiser, videoProcessingConfigurationOptionsFilters.denoiser) &&
        Objects.equals(this.stabilizer, videoProcessingConfigurationOptionsFilters.stabilizer) &&
        Objects.equals(this.augmenter, videoProcessingConfigurationOptionsFilters.augmenter) &&
        Objects.equals(this.scaler, videoProcessingConfigurationOptionsFilters.scaler) &&
        Objects.equals(this.frameRateConverter, videoProcessingConfigurationOptionsFilters.frameRateConverter) &&
        Objects.equals(this.debander, videoProcessingConfigurationOptionsFilters.debander) &&
        Objects.equals(this.postProcessor, videoProcessingConfigurationOptionsFilters.postProcessor);
  }

  @Override
  public int hashCode() {
    return Objects.hash(deinterlacer, reshaper, denoiser, stabilizer, augmenter, scaler, frameRateConverter, debander, postProcessor);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoProcessingConfigurationOptionsFilters {\n");
    sb.append("    deinterlacer: ").append(toIndentedString(deinterlacer)).append("\n");
    sb.append("    reshaper: ").append(toIndentedString(reshaper)).append("\n");
    sb.append("    denoiser: ").append(toIndentedString(denoiser)).append("\n");
    sb.append("    stabilizer: ").append(toIndentedString(stabilizer)).append("\n");
    sb.append("    augmenter: ").append(toIndentedString(augmenter)).append("\n");
    sb.append("    scaler: ").append(toIndentedString(scaler)).append("\n");
    sb.append("    frameRateConverter: ").append(toIndentedString(frameRateConverter)).append("\n");
    sb.append("    debander: ").append(toIndentedString(debander)).append("\n");
    sb.append("    postProcessor: ").append(toIndentedString(postProcessor)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("deinterlacer");
    openapiFields.add("reshaper");
    openapiFields.add("denoiser");
    openapiFields.add("stabilizer");
    openapiFields.add("augmenter");
    openapiFields.add("scaler");
    openapiFields.add("frameRateConverter");
    openapiFields.add("debander");
    openapiFields.add("postProcessor");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoProcessingConfigurationOptionsFilters
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoProcessingConfigurationOptionsFilters.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoProcessingConfigurationOptionsFilters is not found in the empty JSON string", VideoProcessingConfigurationOptionsFilters.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoProcessingConfigurationOptionsFilters.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoProcessingConfigurationOptionsFilters` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("deinterlacer") != null && !jsonObj.get("deinterlacer").isJsonNull()) && !jsonObj.get("deinterlacer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `deinterlacer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("deinterlacer").toString()));
      }
      // validate the optional field `deinterlacer`
      if (jsonObj.get("deinterlacer") != null && !jsonObj.get("deinterlacer").isJsonNull()) {
        DeinterlacerEnum.validateJsonElement(jsonObj.get("deinterlacer"));
      }
      if ((jsonObj.get("reshaper") != null && !jsonObj.get("reshaper").isJsonNull()) && !jsonObj.get("reshaper").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `reshaper` to be a primitive type in the JSON string but got `%s`", jsonObj.get("reshaper").toString()));
      }
      // validate the optional field `reshaper`
      if (jsonObj.get("reshaper") != null && !jsonObj.get("reshaper").isJsonNull()) {
        ReshaperEnum.validateJsonElement(jsonObj.get("reshaper"));
      }
      if ((jsonObj.get("denoiser") != null && !jsonObj.get("denoiser").isJsonNull()) && !jsonObj.get("denoiser").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `denoiser` to be a primitive type in the JSON string but got `%s`", jsonObj.get("denoiser").toString()));
      }
      // validate the optional field `denoiser`
      if (jsonObj.get("denoiser") != null && !jsonObj.get("denoiser").isJsonNull()) {
        DenoiserEnum.validateJsonElement(jsonObj.get("denoiser"));
      }
      if ((jsonObj.get("stabilizer") != null && !jsonObj.get("stabilizer").isJsonNull()) && !jsonObj.get("stabilizer").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `stabilizer` to be a primitive type in the JSON string but got `%s`", jsonObj.get("stabilizer").toString()));
      }
      // validate the optional field `stabilizer`
      if (jsonObj.get("stabilizer") != null && !jsonObj.get("stabilizer").isJsonNull()) {
        StabilizerEnum.validateJsonElement(jsonObj.get("stabilizer"));
      }
      if ((jsonObj.get("augmenter") != null && !jsonObj.get("augmenter").isJsonNull()) && !jsonObj.get("augmenter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `augmenter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("augmenter").toString()));
      }
      // validate the optional field `augmenter`
      if (jsonObj.get("augmenter") != null && !jsonObj.get("augmenter").isJsonNull()) {
        AugmenterEnum.validateJsonElement(jsonObj.get("augmenter"));
      }
      if ((jsonObj.get("scaler") != null && !jsonObj.get("scaler").isJsonNull()) && !jsonObj.get("scaler").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `scaler` to be a primitive type in the JSON string but got `%s`", jsonObj.get("scaler").toString()));
      }
      // validate the optional field `scaler`
      if (jsonObj.get("scaler") != null && !jsonObj.get("scaler").isJsonNull()) {
        ScalerEnum.validateJsonElement(jsonObj.get("scaler"));
      }
      if ((jsonObj.get("frameRateConverter") != null && !jsonObj.get("frameRateConverter").isJsonNull()) && !jsonObj.get("frameRateConverter").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `frameRateConverter` to be a primitive type in the JSON string but got `%s`", jsonObj.get("frameRateConverter").toString()));
      }
      // validate the optional field `frameRateConverter`
      if (jsonObj.get("frameRateConverter") != null && !jsonObj.get("frameRateConverter").isJsonNull()) {
        FrameRateConverterEnum.validateJsonElement(jsonObj.get("frameRateConverter"));
      }
      if ((jsonObj.get("debander") != null && !jsonObj.get("debander").isJsonNull()) && !jsonObj.get("debander").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `debander` to be a primitive type in the JSON string but got `%s`", jsonObj.get("debander").toString()));
      }
      // validate the optional field `debander`
      if (jsonObj.get("debander") != null && !jsonObj.get("debander").isJsonNull()) {
        DebanderEnum.validateJsonElement(jsonObj.get("debander"));
      }
      if ((jsonObj.get("postProcessor") != null && !jsonObj.get("postProcessor").isJsonNull()) && !jsonObj.get("postProcessor").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `postProcessor` to be a primitive type in the JSON string but got `%s`", jsonObj.get("postProcessor").toString()));
      }
      // validate the optional field `postProcessor`
      if (jsonObj.get("postProcessor") != null && !jsonObj.get("postProcessor").isJsonNull()) {
        PostProcessorEnum.validateJsonElement(jsonObj.get("postProcessor"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoProcessingConfigurationOptionsFilters.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoProcessingConfigurationOptionsFilters' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoProcessingConfigurationOptionsFilters> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoProcessingConfigurationOptionsFilters.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoProcessingConfigurationOptionsFilters>() {
           @Override
           public void write(JsonWriter out, VideoProcessingConfigurationOptionsFilters value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoProcessingConfigurationOptionsFilters read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoProcessingConfigurationOptionsFilters given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoProcessingConfigurationOptionsFilters
   * @throws IOException if the JSON string is invalid with respect to VideoProcessingConfigurationOptionsFilters
   */
  public static VideoProcessingConfigurationOptionsFilters fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoProcessingConfigurationOptionsFilters.class);
  }

  /**
   * Convert an instance of VideoProcessingConfigurationOptionsFilters to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

