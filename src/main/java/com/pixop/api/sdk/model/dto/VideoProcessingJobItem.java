/*
 * Pixop API Documentation
 *  The Pixop API provides a comprehensive RESTful interface for interacting with the Pixop Platform. It allows users to manage API keys, projects, videos, and more.  The Pixop Platform offers video processing features such as upscaling, format conversion, and compression. It uses AI-driven algorithms to optimize video quality, reduce file sizes, and improve playback performance.  **Quick Start Guide** - Explore the [Pixop API Documentation](https://docs.pixop.com/reference/) to familiarize yourself with the API's capabilities.  **Required Headers** Include the following headers in all API requests: - `Accept`: `application/json` - `Content-Type`: `application/json` - `X-API-Key`: Your API key for authentication (e.g., `X-API-Key: <your-api-key>`).     **Note:** API key management endpoints that use Basic Authentication do not require the `X-API-Key` header.  **Rate Limits** All endpoints, except those related to API key management, enforce rate limits. Response headers provide the following rate limit details: - `X-RateLimit-Limit`: The maximum number of requests allowed per minute. - `X-RateLimit-Remaining`: The number of requests remaining in the current rate limit window. - `X-RateLimit-Reset`: The number of seconds until the current rate limit window resets. 
 *
 * The version of the OpenAPI document: 1.0.0-rc.3
 * Contact: api@pixop.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.pixop.api.sdk.model.dto;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.pixop.api.sdk.model.dto.AmountUnit;
import com.pixop.api.sdk.model.dto.Category;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Arrays;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.pixop.api.sdk.JSON;

/**
 * VideoProcessingJobItem
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-06-06T09:15:25.070713506Z[UTC]", comments = "Generator version: 7.12.0")
public class VideoProcessingJobItem {
  public static final String SERIALIZED_NAME_PRODUCT_NAME = "productName";
  @SerializedName(SERIALIZED_NAME_PRODUCT_NAME)
  @javax.annotation.Nullable
  private String productName;

  public static final String SERIALIZED_NAME_CATEGORY = "category";
  @SerializedName(SERIALIZED_NAME_CATEGORY)
  @javax.annotation.Nullable
  private Category category;

  public static final String SERIALIZED_NAME_AMOUNT = "amount";
  @SerializedName(SERIALIZED_NAME_AMOUNT)
  @javax.annotation.Nullable
  private BigDecimal amount;

  public static final String SERIALIZED_NAME_AMOUNT_UNIT = "amountUnit";
  @SerializedName(SERIALIZED_NAME_AMOUNT_UNIT)
  @javax.annotation.Nullable
  private AmountUnit amountUnit;

  public static final String SERIALIZED_NAME_DISCOUNT_PERCENTAGE = "discountPercentage";
  @SerializedName(SERIALIZED_NAME_DISCOUNT_PERCENTAGE)
  @javax.annotation.Nullable
  private BigDecimal discountPercentage;

  public static final String SERIALIZED_NAME_UNIT_PRICE_USD = "unitPriceUsd";
  @SerializedName(SERIALIZED_NAME_UNIT_PRICE_USD)
  @javax.annotation.Nullable
  private BigDecimal unitPriceUsd;

  public static final String SERIALIZED_NAME_COST_USD = "costUsd";
  @SerializedName(SERIALIZED_NAME_COST_USD)
  @javax.annotation.Nullable
  private BigDecimal costUsd;

  public static final String SERIALIZED_NAME_DISCOUNT_USD = "discountUsd";
  @SerializedName(SERIALIZED_NAME_DISCOUNT_USD)
  @javax.annotation.Nullable
  private BigDecimal discountUsd;

  public static final String SERIALIZED_NAME_NORMAL_COST_USD = "normalCostUsd";
  @SerializedName(SERIALIZED_NAME_NORMAL_COST_USD)
  @javax.annotation.Nullable
  private BigDecimal normalCostUsd;

  public VideoProcessingJobItem() {
  }

  public VideoProcessingJobItem(
     String productName, 
     Category category, 
     BigDecimal amount, 
     AmountUnit amountUnit, 
     BigDecimal discountPercentage
  ) {
    this();
    this.productName = productName;
    this.category = category;
    this.amount = amount;
    this.amountUnit = amountUnit;
    this.discountPercentage = discountPercentage;
  }

  /**
   * The name of the product, such as an encoder or filter. For example, H.264 / AVC.
   * @return productName
   */
  @javax.annotation.Nullable
  public String getProductName() {
    return productName;
  }



  /**
   * The category to which this product belongs.
   * @return category
   */
  @javax.annotation.Nullable
  public Category getCategory() {
    return category;
  }



  /**
   * The quantity of the product or service consumed.
   * @return amount
   */
  @javax.annotation.Nullable
  public BigDecimal getAmount() {
    return amount;
  }



  /**
   * The unit for the specified amount, such as USD, GB, or GP.
   * @return amountUnit
   */
  @javax.annotation.Nullable
  public AmountUnit getAmountUnit() {
    return amountUnit;
  }



  /**
   * Represents the discount percentage applied to a cost or product. For example, 3.3 indicates a 3.3% discount.
   * minimum: 0
   * maximum: 100
   * @return discountPercentage
   */
  @javax.annotation.Nullable
  public BigDecimal getDiscountPercentage() {
    return discountPercentage;
  }



  public VideoProcessingJobItem unitPriceUsd(@javax.annotation.Nullable BigDecimal unitPriceUsd) {
    this.unitPriceUsd = unitPriceUsd;
    return this;
  }

  /**
   * Represents an amount of money with up to three decimal places, e.g., 1.341 USD.
   * @return unitPriceUsd
   */
  @javax.annotation.Nullable
  public BigDecimal getUnitPriceUsd() {
    return unitPriceUsd;
  }

  public void setUnitPriceUsd(@javax.annotation.Nullable BigDecimal unitPriceUsd) {
    this.unitPriceUsd = unitPriceUsd;
  }


  public VideoProcessingJobItem costUsd(@javax.annotation.Nullable BigDecimal costUsd) {
    this.costUsd = costUsd;
    return this;
  }

  /**
   * Represents an amount of money with up to three decimal places, e.g., 1.341 USD.
   * @return costUsd
   */
  @javax.annotation.Nullable
  public BigDecimal getCostUsd() {
    return costUsd;
  }

  public void setCostUsd(@javax.annotation.Nullable BigDecimal costUsd) {
    this.costUsd = costUsd;
  }


  public VideoProcessingJobItem discountUsd(@javax.annotation.Nullable BigDecimal discountUsd) {
    this.discountUsd = discountUsd;
    return this;
  }

  /**
   * Represents an amount of money with up to three decimal places, e.g., 1.341 USD.
   * @return discountUsd
   */
  @javax.annotation.Nullable
  public BigDecimal getDiscountUsd() {
    return discountUsd;
  }

  public void setDiscountUsd(@javax.annotation.Nullable BigDecimal discountUsd) {
    this.discountUsd = discountUsd;
  }


  public VideoProcessingJobItem normalCostUsd(@javax.annotation.Nullable BigDecimal normalCostUsd) {
    this.normalCostUsd = normalCostUsd;
    return this;
  }

  /**
   * Represents an amount of money with up to three decimal places, e.g., 1.341 USD.
   * @return normalCostUsd
   */
  @javax.annotation.Nullable
  public BigDecimal getNormalCostUsd() {
    return normalCostUsd;
  }

  public void setNormalCostUsd(@javax.annotation.Nullable BigDecimal normalCostUsd) {
    this.normalCostUsd = normalCostUsd;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VideoProcessingJobItem videoProcessingJobItem = (VideoProcessingJobItem) o;
    return Objects.equals(this.productName, videoProcessingJobItem.productName) &&
        Objects.equals(this.category, videoProcessingJobItem.category) &&
        Objects.equals(this.amount, videoProcessingJobItem.amount) &&
        Objects.equals(this.amountUnit, videoProcessingJobItem.amountUnit) &&
        Objects.equals(this.discountPercentage, videoProcessingJobItem.discountPercentage) &&
        Objects.equals(this.unitPriceUsd, videoProcessingJobItem.unitPriceUsd) &&
        Objects.equals(this.costUsd, videoProcessingJobItem.costUsd) &&
        Objects.equals(this.discountUsd, videoProcessingJobItem.discountUsd) &&
        Objects.equals(this.normalCostUsd, videoProcessingJobItem.normalCostUsd);
  }

  @Override
  public int hashCode() {
    return Objects.hash(productName, category, amount, amountUnit, discountPercentage, unitPriceUsd, costUsd, discountUsd, normalCostUsd);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VideoProcessingJobItem {\n");
    sb.append("    productName: ").append(toIndentedString(productName)).append("\n");
    sb.append("    category: ").append(toIndentedString(category)).append("\n");
    sb.append("    amount: ").append(toIndentedString(amount)).append("\n");
    sb.append("    amountUnit: ").append(toIndentedString(amountUnit)).append("\n");
    sb.append("    discountPercentage: ").append(toIndentedString(discountPercentage)).append("\n");
    sb.append("    unitPriceUsd: ").append(toIndentedString(unitPriceUsd)).append("\n");
    sb.append("    costUsd: ").append(toIndentedString(costUsd)).append("\n");
    sb.append("    discountUsd: ").append(toIndentedString(discountUsd)).append("\n");
    sb.append("    normalCostUsd: ").append(toIndentedString(normalCostUsd)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("productName");
    openapiFields.add("category");
    openapiFields.add("amount");
    openapiFields.add("amountUnit");
    openapiFields.add("discountPercentage");
    openapiFields.add("unitPriceUsd");
    openapiFields.add("costUsd");
    openapiFields.add("discountUsd");
    openapiFields.add("normalCostUsd");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to VideoProcessingJobItem
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!VideoProcessingJobItem.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in VideoProcessingJobItem is not found in the empty JSON string", VideoProcessingJobItem.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!VideoProcessingJobItem.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `VideoProcessingJobItem` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("productName") != null && !jsonObj.get("productName").isJsonNull()) && !jsonObj.get("productName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `productName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("productName").toString()));
      }
      // validate the optional field `category`
      if (jsonObj.get("category") != null && !jsonObj.get("category").isJsonNull()) {
        Category.validateJsonElement(jsonObj.get("category"));
      }
      // validate the optional field `amountUnit`
      if (jsonObj.get("amountUnit") != null && !jsonObj.get("amountUnit").isJsonNull()) {
        AmountUnit.validateJsonElement(jsonObj.get("amountUnit"));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!VideoProcessingJobItem.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'VideoProcessingJobItem' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<VideoProcessingJobItem> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(VideoProcessingJobItem.class));

       return (TypeAdapter<T>) new TypeAdapter<VideoProcessingJobItem>() {
           @Override
           public void write(JsonWriter out, VideoProcessingJobItem value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public VideoProcessingJobItem read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of VideoProcessingJobItem given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of VideoProcessingJobItem
   * @throws IOException if the JSON string is invalid with respect to VideoProcessingJobItem
   */
  public static VideoProcessingJobItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, VideoProcessingJobItem.class);
  }

  /**
   * Convert an instance of VideoProcessingJobItem to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

